"""
Estimate nodes and routes/edges risk using random risk values
instead of API requests to INARISK.

@author yohanes.gultom@gmail.com
"""

import os
import csv
import random
import pandas as pd

def generate_random_risks(dataframe):
    """
    Generate random risk values between 0 and 0.9 for the given dataframe.
    
    Args:
        dataframe (pd.DataFrame): DataFrame containing node data.
    
    Returns:
        pd.DataFrame: Updated DataFrame with random risks.
    """
    dataframe["Risk"] = [random.uniform(0, 0.9) for _ in range(len(dataframe))]
    return dataframe


def generate_risk_from_pycgr(input_path: str):
    """
    Read input pycgr/pycgrc from {input_path},
    get the nodes and routes/edges/networks risk 
    based on random risk values,
    and write the output to {input_path}_node_risk and {input_path}_risk.

    Args:
        input_path (str): path to pycgr file generated by AndGem/OsmToRoadGraph
    """

    node_id_latlon = []
    link_info = []
    total_nodes = None
    total_edges = None
    count_edges = 0
    count_nodes = 0
    print(f'Reading {input_path}')
    with open(input_path) as f:
        count = 0
        for line in f:
            if count == 7:
                total_nodes = int(line)
            elif count == 8:
                total_edges = int(line)
            elif count > 8:
                if count_nodes < total_nodes:
                    # Start reading nodes
                    node_id, lat, lon = line.split()
                    node_id_latlon.append([node_id, float(lat), float(lon)])
                    count_nodes += 1
                else:
                    # Read edges
                    source_id, target_id, length, street_type, max_speed, bidirectional = line.split()
                    link_info.append([source_id, target_id, length, max_speed, bidirectional])
                    count_edges += 1
            count += 1

    assert count_nodes == total_nodes
    assert count_edges == total_edges

    # Pandas DataFrame for nodes
    pd_node_risk = pd.DataFrame(node_id_latlon, columns=["Node Id", "Latitude", "Longitude"])

    # Assign random risks
    pd_node_risk = generate_random_risks(pd_node_risk)

    # Generate edge risks as the maximum risk of source and target nodes
    link_risk = []
    for edge in link_info:
        source, target, length, max_speed, bidirectional = edge
        source_risk = pd_node_risk.loc[pd_node_risk["Node Id"] == source, "Risk"].values[0]
        target_risk = pd_node_risk.loc[pd_node_risk["Node Id"] == target, "Risk"].values[0]
        edge_risk = max(source_risk, target_risk)
        link_risk.append([source, target, edge_risk, length, max_speed, bidirectional])

    # Save nodes/location risk
    with open(input_path + '_node_risk', 'w+') as f:
        writer = csv.writer(f, delimiter=' ')
        for _, row in pd_node_risk.iterrows():
            writer.writerow((row["Node Id"], row["Risk"]))

    # Save edges/network risk
    with open(input_path + '_risk', 'w+') as f:
        writer = csv.writer(f, delimiter=' ')
        for source_id, target_id, edge_risk, length, max_speed, bidirectional in link_risk:
            writer.writerow((source_id, target_id, edge_risk, length, max_speed, bidirectional))

